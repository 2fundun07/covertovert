# Covert Timing Channel

This project implements a covert timing channel that leverages inter-arrival times of packets at the LLC (Logical Link Control) layer. The covert channel encodes binary messages (bits) into timing intervals between packets and transmits them across a network. The receiver decodes the message by interpreting these inter-arrival times. This project is designed as a proof of concept for covert communication over a network and demonstrates the trade-offs between throughput, timing accuracy, and network noise.

Each bit is encoded into a timing interval: a bit '0' is sent after a short delay, and a bit '1' is sent after a long delay. The receiver measures the inter-arrival time between packets to determine if the bit was '0' or '1'. A threshold (threshold_ms) is used to differentiate between the two delays. The sender generates a random binary message of 128 bits (16 characters) and encodes each bit into inter-packet delays before transmitting packets with dummy payloads. The receiver captures packets and decodes the message based on the measured inter-arrival times.

The covert channel's capacity is calculated by dividing the number of bits sent by the total transmission time. The sender encodes each bit into a timing delay: for '0', a random delay between 0 and threshold_ms - error_ms is used, and for '1', a random delay between threshold_ms + error_ms and 2 * threshold_ms. The receiver captures incoming packets, measures the inter-arrival times, and decodes the bits accordingly.

In the experimental setup, the threshold was set to 200 ms and the error margin to 100 ms, resulting in a measured capacity of approximately 4 bits per second. The performance is limited by several factors. The resolution of the system clock and network jitter restrict the accuracy of timing intervals, potentially leading to decoding errors if the system's clock resolution is too low (e.g., 1 ms). High network jitter can blur the distinction between '0' and '1' delays, reducing accuracy. To mitigate this, larger gaps between delays (e.g., 50 ms vs. 100 ms) were used, but this reduces capacity. Furthermore, the threshold_ms and error_ms values must be carefully tuned for each environment. A threshold that's too small can cause overlap between '0' and '1' delays due to jitter, while a threshold that's too large reduces capacity.
